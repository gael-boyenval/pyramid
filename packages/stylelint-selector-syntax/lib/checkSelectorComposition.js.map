{"version":3,"sources":["../src/checkSelectorComposition.ts"],"names":["ruleName","messages","stylelint","utils","ruleMessages","invalidClassMutation","selector","primaryClass","secondaryClass","invalidTagMutation","tag","invalidClassMutationWithinTag","classIsNotComposable","primaryClassValue","primaryClassType","checkSecondaryClass","nextSelector","previousSelector","allowed","rule","result","blockIdentifier","blockType","name","report","message","value","node","checkSecondaryTag","check","type","str","allowComposition","includes","length","checkSelectorComposition","decomposedSelector","filter","part","forEach","index","array"],"mappings":";;;;;;;AAAA;;;;AAQO,IAAMA,QAAQ,GAAG,gBAAjB;;;AAEA,IAAMC,QAAQ,GAAGC,mBAAUC,KAAV,CAAgBC,YAAhB,CAA6BJ,QAA7B,EAAuC;AAC7DK,EAAAA,oBAAoB,EAAE,8BAACC,QAAD,EAAWC,YAAX,EAAyBC,cAAzB;AAAA,4CACKA,cADL,0BACiCD,YADjC,qBACsDD,QADtD;AAAA,GADuC;AAG7DG,EAAAA,kBAAkB,EAAE,4BAACH,QAAD,EAAWI,GAAX;AAAA,6CACQA,GADR,qBACoBJ,QADpB;AAAA,GAHyC;AAK7DK,EAAAA,6BAA6B,EAAE,uCAACL,QAAD,EAAWI,GAAX,EAAgBF,cAAhB;AAAA,4CACJA,cADI,2BACyBE,GADzB,yBACyCJ,QADzC;AAAA,GAL8B;AAO7DM,EAAAA,oBAAoB,EAAE,8BAACN,QAAD,EAAWO,iBAAX,EAA8BC,gBAA9B;AAAA,gCACPA,gBADO,yBACsBD,iBADtB,sCACiEP,QADjE;AAAA;AAPuC,CAAvC,CAAjB;;;;AAeP,IAAMS,mBAAmB,GAAG,SAAtBA,mBAAsB,CAC1BC,YAD0B,EAE1BC,gBAF0B,EAG1BC,OAH0B,EAI1BC,IAJ0B,EAK1BnB,QAL0B,EAM1BoB,MAN0B,EAOjB;AACT,MAAIJ,YAAY,CAACK,eAAb,KAAiCJ,gBAAgB,CAACI,eAAtD,EAAuE;;AAGvE,MACEL,YAAY,CAACM,SAAb,CAAuBC,IAAvB,KAAgC,SAAhC,IACAN,gBAAgB,CAACK,SAAjB,CAA2BC,IAA3B,KAAoC,SAFtC,EAGE;AACA;AACD;;AAGD,MACE,CAACL,OAAO,CAAC,SAAS,UAAV,CAAR,IACAD,gBAAgB,CAACK,SAAjB,CAA2BC,IAA3B,KAAoCP,YAAY,CAACM,SAAb,CAAuBC,IAD3D,IAEA,CAACL,OAAO,CAACF,YAAY,CAACM,SAAb,CAAuBC,IAAxB,CAHV,EAIE;AACA,WAAOrB,mBAAUC,KAAV,CAAgBqB,MAAhB,CAAuB;AAC5BC,MAAAA,OAAO,EAAExB,QAAQ,CAACI,oBAAT,CACPc,IAAI,CAACb,QADE,EAEPW,gBAAgB,CAACS,KAFV,EAGPV,YAAY,CAACU,KAHN,CADmB;AAM5BC,MAAAA,IAAI,EAAER,IANsB;AAO5BC,MAAAA,MAAM,EAAEA,MAPoB;AAQ5BpB,MAAAA,QAAQ,EAAEA;AARkB,KAAvB,CAAP;AAUD;;AAGD,MAAI,CAACkB,OAAO,CAAC,SAAS,UAAV,CAAR,IAAiC,CAACA,OAAO,CAACF,YAAY,CAACM,SAAb,CAAuBC,IAAxB,CAA7C,EAA4E;AAC1E,WAAOrB,mBAAUC,KAAV,CAAgBqB,MAAhB,CAAuB;AAC5BC,MAAAA,OAAO,EAAExB,QAAQ,CAACI,oBAAT,CACPc,IAAI,CAACb,QADE,EAEPW,gBAAgB,CAACS,KAFV,EAGPV,YAAY,CAACU,KAHN,CADmB;AAM5BC,MAAAA,IAAI,EAAER,IANsB;AAO5BC,MAAAA,MAAM,EAAEA,MAPoB;AAQ5BpB,MAAAA,QAAQ,EAAEA;AARkB,KAAvB,CAAP;AAUD;AACF,CAjDD;;AAqDA,IAAM4B,iBAAiB,GAAG,SAApBA,iBAAoB,CACxBV,OADwB,EAExBC,IAFwB,EAGxBnB,QAHwB,EAIxBoB,MAJwB,EAKxBV,GALwB,EAMf;AACT,MAAI,CAACQ,OAAO,CAAC,KAAD,CAAZ,EAAqB;AACnB,WAAOhB,mBAAUC,KAAV,CAAgBqB,MAAhB,CAAuB;AAC5BC,MAAAA,OAAO,EAAExB,QAAQ,CAACQ,kBAAT,CAA4BU,IAAI,CAACb,QAAjC,EAA2CI,GAA3C,CADmB;AAE5BiB,MAAAA,IAAI,EAAER,IAFsB;AAG5BC,MAAAA,MAAM,EAAEA,MAHoB;AAI5BpB,MAAAA,QAAQ,EAAEA;AAJkB,KAAvB,CAAP;AAMD;AACF,CAfD;;AAiBA,IAAM6B,KAAK,GAAG,SAARA,KAAQ,CACZZ,gBADY,EAEZD,YAFY,EAGZG,IAHY,EAIZnB,QAJY,EAKZoB,MALY,EAMQ;AACpB,MAAIH,gBAAgB,CAACa,IAAjB,KAA0B,KAA1B,IAAmCd,YAAY,CAACc,IAAb,KAAsB,KAA7D,EAAoE;AAClE;AACD;;AAGD,MAAIb,gBAAgB,CAACa,IAAjB,KAA0B,KAA1B,IAAmCd,YAAY,CAACc,IAAb,KAAsB,OAA7D,EAAsE;AACpE,WAAO5B,mBAAUC,KAAV,CAAgBqB,MAAhB,CAAuB;AAC5BC,MAAAA,OAAO,EAAExB,QAAQ,CAACU,6BAAT,CACPQ,IAAI,CAACb,QADE,EAEPW,gBAAgB,CAACS,KAFV,EAGPV,YAAY,CAACU,KAHN,CADmB;AAM5BC,MAAAA,IAAI,EAAER,IANsB;AAO5BC,MAAAA,MAAM,EAAEA,MAPoB;AAQ5BpB,MAAAA,QAAQ,EAAEA;AARkB,KAAvB,CAAP;AAUD;;AAED,MAAMkB,OAAgB,GAAG,SAAnBA,OAAmB,CAACa,GAAD;AAAA,WACvBd,gBAAgB,CAACK,SAAjB,CAA2BU,gBAA3B,CAA4CC,QAA5C,CAAqDF,GAArD,CADuB;AAAA,GAAzB;;AAIA,MACEd,gBAAgB,CAACK,SAAjB,CAA2BC,IAA3B,KAAoC,SAApC,IACAN,gBAAgB,CAACK,SAAjB,CAA2BU,gBAA3B,CAA4CE,MAA5C,KAAuD,CAFzD,EAGE;AACA,WAAOhC,mBAAUC,KAAV,CAAgBqB,MAAhB,CAAuB;AAC5BC,MAAAA,OAAO,EAAExB,QAAQ,CAACW,oBAAT,CACPO,IAAI,CAACb,QADE,EAEPW,gBAAgB,CAACS,KAFV,EAGPT,gBAAgB,CAACK,SAAjB,CAA2BC,IAHpB,CADmB;AAM5BI,MAAAA,IAAI,EAAER,IANsB;AAO5BC,MAAAA,MAAM,EAAEA,MAPoB;AAQ5BpB,MAAAA,QAAQ,EAAEA;AARkB,KAAvB,CAAP;AAUD;;AAED,UAAQgB,YAAY,CAACc,IAArB;AACE,SAAK,OAAL;AACEf,MAAAA,mBAAmB,CACjBC,YADiB,EAEjBC,gBAFiB,EAGjBC,OAHiB,EAIjBC,IAJiB,EAKjBnB,QALiB,EAMjBoB,MANiB,CAAnB;AAQA;;AACF,SAAK,KAAL;AACEQ,MAAAA,iBAAiB,CAACV,OAAD,EAAUC,IAAV,EAAgBnB,QAAhB,EAA0BoB,MAA1B,EAAkCJ,YAAY,CAACU,KAA/C,CAAjB;AACA;AAbJ;AAeD,CA5DD;;AAkEA,IAAMS,wBAAwB,GAAG,SAA3BA,wBAA2B,CAC/BC,kBAD+B,EAE/BjB,IAF+B,EAG/BC,MAH+B,EAI/BpB,QAJ+B,EAKtB;AAGT,MAAIoC,kBAAkB,CAACF,MAAnB,KAA8B,CAAlC,EAAqC;AACnC;AACD;;AAEDE,EAAAA,kBAAkB,CACfC,MADH,CACU,UAACC,IAAD;AAAA,WAAUA,IAAI,CAACR,IAAL,KAAc,KAAd,IAAuBQ,IAAI,CAACR,IAAL,KAAc,OAA/C;AAAA,GADV,EAEGS,OAFH,CAEW,UAACD,IAAD,EAAOE,KAAP,EAAcC,KAAd,EAAwB;AAC/B,QAAMzB,YAAY,GAAGyB,KAAK,CAACD,KAAK,GAAG,CAAT,CAA1B;;AACA,QAAIxB,YAAJ,EAAkB;AAChBa,MAAAA,KAAK,CAACS,IAAD,EAAOtB,YAAP,EAAqBG,IAArB,EAA2BnB,QAA3B,EAAqCoB,MAArC,CAAL;AACD;AACF,GAPH;AAQD,CApBD;;eAsBee,wB","sourcesContent":["import stylelint from 'stylelint';\nimport { PyramidSelector, PyramidSelectorPart, PyramidRule } from './selectors';\nimport { Result } from 'postcss';\n\n/*\n  REPORTS MESSAGES\n*/\n\nexport const ruleName = 'plugin/pyramid';\n\nexport const messages = stylelint.utils.ruleMessages(ruleName, {\n  invalidClassMutation: (selector, primaryClass, secondaryClass) =>\n    `Invalid mutation of \".${secondaryClass}\" within \".${primaryClass}\" in \"${selector}\"`,\n  invalidTagMutation: (selector, tag) =>\n    `Invalid mutation of a \"${tag}\" in \"${selector}\", use classes instead`,\n  invalidClassMutationWithinTag: (selector, tag, secondaryClass) =>\n    `Invalid mutation of \".${secondaryClass}\" within a \"${tag}\" tag in \"${selector}\"`,\n  classIsNotComposable: (selector, primaryClassValue, primaryClassType) =>\n    `Expected \"${primaryClassType}\" class \".${primaryClassValue}\" to be standalone in \"${selector}\"`,\n});\n\n/*\n  CHECK UPON SECONDARY SELECTOR ELEMENTS\n*/\n\nconst checkSecondaryClass = (\n  nextSelector: PyramidSelectorPart,\n  previousSelector: PyramidSelectorPart,\n  allowed: Allowed,\n  rule: PyramidRule,\n  ruleName: string,\n  result: Result,\n): void => {\n  if (nextSelector.blockIdentifier === previousSelector.blockIdentifier) return;\n\n  // if both classes are without identifier\n  if (\n    nextSelector.blockType.name === 'unknown' &&\n    previousSelector.blockType.name === 'unknown'\n  ) {\n    return;\n  }\n\n  /* same block type, diferent block identifer */\n  if (\n    !allowed('any' || 'anyClass') &&\n    previousSelector.blockType.name === nextSelector.blockType.name &&\n    !allowed(nextSelector.blockType.name)\n  ) {\n    return stylelint.utils.report({\n      message: messages.invalidClassMutation(\n        rule.selector,\n        previousSelector.value,\n        nextSelector.value,\n      ),\n      node: rule,\n      result: result,\n      ruleName: ruleName,\n    });\n  }\n\n  /* diferent block type, diferent block identifer */\n  if (!allowed('any' || 'anyClass') && !allowed(nextSelector.blockType.name)) {\n    return stylelint.utils.report({\n      message: messages.invalidClassMutation(\n        rule.selector,\n        previousSelector.value,\n        nextSelector.value,\n      ),\n      node: rule,\n      result: result,\n      ruleName: ruleName,\n    });\n  }\n};\n\ntype Allowed = (str: string) => boolean;\n\nconst checkSecondaryTag = (\n  allowed: Allowed,\n  rule: PyramidRule,\n  ruleName: string,\n  result: Result,\n  tag: string,\n): void => {\n  if (!allowed('any')) {\n    return stylelint.utils.report({\n      message: messages.invalidTagMutation(rule.selector, tag),\n      node: rule,\n      result: result,\n      ruleName: ruleName,\n    });\n  }\n};\n\nconst check = (\n  previousSelector: PyramidSelectorPart,\n  nextSelector: PyramidSelectorPart,\n  rule: PyramidRule,\n  ruleName: string,\n  result: Result,\n): void | Function => {\n  if (previousSelector.type === 'tag' && nextSelector.type === 'tag') {\n    return;\n  }\n\n  // disalow tags modifying classes\n  if (previousSelector.type === 'tag' && nextSelector.type === 'class') {\n    return stylelint.utils.report({\n      message: messages.invalidClassMutationWithinTag(\n        rule.selector,\n        previousSelector.value,\n        nextSelector.value,\n      ),\n      node: rule,\n      result: result,\n      ruleName: ruleName,\n    });\n  }\n\n  const allowed: Allowed = (str) =>\n    previousSelector.blockType.allowComposition.includes(str);\n\n  // if the previousSelector block type is not unknown and as no allowed composition, we error\n  if (\n    previousSelector.blockType.name !== 'unknown' &&\n    previousSelector.blockType.allowComposition.length === 0\n  ) {\n    return stylelint.utils.report({\n      message: messages.classIsNotComposable(\n        rule.selector,\n        previousSelector.value,\n        previousSelector.blockType.name,\n      ),\n      node: rule,\n      result: result,\n      ruleName: ruleName,\n    });\n  }\n\n  switch (nextSelector.type) {\n    case 'class':\n      checkSecondaryClass(\n        nextSelector,\n        previousSelector,\n        allowed,\n        rule,\n        ruleName,\n        result,\n      );\n      break;\n    case 'tag':\n      checkSecondaryTag(allowed, rule, ruleName, result, nextSelector.value);\n      break;\n  }\n};\n\n/*\n  MAIN CHECKS\n*/\n\nconst checkSelectorComposition = (\n  decomposedSelector: PyramidSelector,\n  rule: PyramidRule,\n  result: Result,\n  ruleName: string,\n): void => {\n  // if the selector is composed of only one element,\n  // we do not check for composition errors\n  if (decomposedSelector.length === 1) {\n    return;\n  }\n\n  decomposedSelector\n    .filter((part) => part.type === 'tag' || part.type === 'class')\n    .forEach((part, index, array) => {\n      const nextSelector = array[index + 1];\n      if (nextSelector) {\n        check(part, nextSelector, rule, ruleName, result);\n      }\n    });\n};\n\nexport default checkSelectorComposition;\n"],"file":"checkSelectorComposition.js"}